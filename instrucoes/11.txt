Instru√ß√£o Para a IA de Programa√ß√£o: Implementar o Painel de Controle e Orienta√ß√£o dos Agentes

Objetivo: Evoluir o sistema existente para incluir uma interface de controle avan√ßada e robusta que permita ao usu√°rio especialista (1) configurar dinamicamente as instru√ß√µes, prompts e prioridades dos agentes de forma persistente e segura, e (2) auditar o processo de decis√£o passo a passo para cada consulta processada, fornecendo feedback corretivo imediato via orienta√ß√£o manual. Essa implementa√ß√£o deve ser integrada ao frontend Gradio j√° existente no projeto (em app_principal.py), garantindo compatibilidade total com o backend FastAPI. Todas as mudan√ßas devem ser testadas unitariamente para evitar regress√µes, e o c√≥digo deve seguir padr√µes PEP8 com coment√°rios detalhados em cada se√ß√£o modificada.

Fase A: Funda√ß√£o do Controle (Backend)

Tarefa 1: Criar o Ficheiro de Configura√ß√£o Central dos Agentes
Centralize todas as "regras", "personalidades" e configura√ß√µes dos agentes em um √∫nico ficheiro JSON para facilitar leituras, modifica√ß√µes e persist√™ncia din√¢mica. Isso garante que as altera√ß√µes sejam aplicadas em tempo de execu√ß√£o sem reiniciar o servidor, exceto quando explicitamente necess√°rio.

1. A√ß√£o: Na raiz do projeto (diret√≥rio principal, ao lado de app_principal.py e outros arquivos raiz), crie um novo ficheiro chamado agents_config.json. Certifique-se de que o ficheiro seja criado com permiss√µes de leitura/escrita (chmod 644 em ambientes Unix-like) e adicione-o ao .gitignore se contiver segredos sens√≠veis.

2. C√≥digo para colocar no agents_config.json (copie exatamente este JSON, garantindo indenta√ß√£o de 4 espa√ßos e codifica√ß√£o UTF-8):
   ```json
   {
     "reasoner_agent": {
       "model": "gpt-4o-mini",
       "base_prompt": "Voc√™ √© um engenheiro de especifica√ß√µes s√™nior, extremamente detalhista. Sua tarefa √© analisar a solicita√ß√£o de um usu√°rio e escolher o servi√ßo mais adequado de uma lista de candidatos, prestando aten√ß√£o m√°xima √†s caracter√≠sticas t√©cnicas. Adjetivos que definem uma propriedade f√≠sica, material ou tipo (ex: 'corrugado', 'r√≠gido', 'estrutural', 'manual') s√£o CR√çTICOS e devem ter um peso maior na sua decis√£o. Sempre priorize precis√£o sobre velocidade e explique cada passo de racioc√≠nio.",
       "user_guidance_template": "\n\nInstru√ß√£o Adicional do Especialista (prioridade m√°xima): {guidance}. Integre esta orienta√ß√£o em todos os passos de an√°lise, sobrepondo-a ao prompt base se houver conflito."
     },
     "classifier_agent": {
       "model": "gpt-4o-mini",
       "base_prompt": "Voc√™ √© um classificador especialista em servi√ßos de constru√ß√£o civil. Analise a query e retorne apenas o grupo e unidade mais prov√°veis baseados nos dados hist√≥ricos. Use JSON estrito como sa√≠da."
     },
     "project_priorities": {
       "default": ["sinapi", "sicro", "cpos_edificacoes", "cpos_infraestrutura", "cdhu"],
       "obras_federais": ["sinapi", "sicro"],
       "prefeitura_sp": ["sp_obras", "sinapi"]
     }
   }
   ```

Tarefa 2: Refatorar os Agentes para Usar a Configura√ß√£o Din√¢mica
Refatore os agentes para carregar configura√ß√µes do ficheiro JSON no momento de inicializa√ß√£o, permitindo recarregamento din√¢mico sem downtime. Isso inclui valida√ß√£o de JSON para evitar erros de parsing.

1. A√ß√£o: Modifique o backend/services/reasoner.py (anteriormente app/reasoner.py, ajustando o path se necess√°rio) e backend/services/classifier_agent.py para carregar o modelo e o prompt do agents_config.json nos seus m√©todos __init__. Use a biblioteca json para leitura, e adicione try-except para lidar com FileNotFoundError ou JSONDecodeError, caindo para valores default hardcoded se o ficheiro falhar. No ReasonerAgent, atualize _build_expert_prompt para concatenar base_prompt com user_guidance_template se guidance for fornecido.

2. A√ß√£o: Modifique o backend/services/finder.py (anteriormente app/finder.py) para aceitar um novo par√¢metro priority_list: list[str] = None no m√©todo hybrid_search. Dentro do m√©todo, ap√≥s calcular fused_scores, implemente uma l√≥gica de boost: para cada idx em fused_scores, verifique item['fonte'] contra priority_list; se a fonte estiver na lista, multiplique o score por (1 + (len(priority_list) - posi√ß√£o_na_lista) * 0.2), onde posi√ß√£o_na_lista √© o √≠ndice (0 para topo = boost m√°ximo). Se priority_list for None, use o "default" do config. Adicione logging.debug para registrar boosts aplicados.

3. A√ß√£o: Em backend/api/routes.py, atualize o endpoint /buscar para aceitar "project_profile": str (opcional, default="default") e "user_guidance": str (opcional) no modelo SearchQuery. Passe priority_list do config['project_priorities'][project_profile] para hybrid_search, e user_guidance para reasoner_instance.choose_best_option.

Tarefa 3: Implementar o Sistema de Trace Detalhado
Crie um "gravador de voo" abrangente para cada consulta, registrando todos os passos em um dicion√°rio estruturado para f√°cil visualiza√ß√£o e depura√ß√£o.

1. A√ß√£o: Em backend/api/routes.py (anteriormente app/main.py ou routes.py, ajustando conforme estrutura), no endpoint buscar_servicos (fun√ß√£o async def buscar_servicos), inicialize um dicion√°rio trace = {"steps": []} no in√≠cio. Em cada etapa (extra√ß√£o de keywords, classifica√ß√£o, busca inicial, racioc√≠nio, busca web se aplic√°vel, adi√ß√£o de vizinhos), adicione entradas como trace["steps"].append({"step_name": "Classifica√ß√£o", "input": query.texto_busca, "output": (predicted_group, predicted_unit), "timestamp": datetime.now().isoformat()}). Inclua erros potenciais em uma chave "errors" se ocorrerem.

2. A√ß√£o: Modifique o modelo SearchResponse para incluir um campo trace: dict = Field(default_factory=dict, description="Dicion√°rio detalhado do trace de execu√ß√£o"). No return SearchResponse, passe trace=trace. Atualize o endpoint para retornar HTTP 200 mesmo com traces de erro, garantindo que o trace capture exce√ß√µes.

Fase B: A Interface de Controle (Frontend)

Tarefa 4: Integrar a Nova "Sala de Controle" no Gradio Existente
Integre uma nova aba de controle avan√ßado diretamente no app_principal.py (o frontend Gradio existente), usando blocos Gradio para layout responsivo. Isso evita criar um novo ficheiro separado, mantendo tudo centralizado. Use gr.Tab para adicionar a aba "Painel de Controle dos Agentes". Certifique-se de que a interface seja wide (largura m√°xima), com valida√ß√µes de input e feedback visual (spinners, sucessos/erros).

1. A√ß√£o: Abra app_principal.py e, dentro da fun√ß√£o create_dashboard() ou equivalente (onde os Tabs principais s√£o definidos), adicione uma nova gr.Tab("Painel de Controle dos Agentes"). Use with gr.Row() para dividir em colunas (esquerda para configura√ß√£o, direita para teste/trace), com variant="panel" para um visual profissional.

2. C√≥digo para integrar no app_principal.py (insira este bloco dentro do with gr.Blocks() as demo:, ap√≥s as abas existentes; ajuste imports se necess√°rio adicionando import json, import requests, from datetime import datetime; certifique-se de que API_URL = "http://127.0.0.1:8000/buscar" esteja definido globalmente):
   ```python
   with gr.Tab("üî¨ Painel de Controle e Orienta√ß√£o dos Agentes"):
       gr.Markdown("### ‚öôÔ∏è Configura√ß√£o e Controle Avan√ßado dos Agentes\nAqui voc√™ pode editar prompts, prioridades e auditar traces em tempo real. Todas as altera√ß√µes s√£o salvas persistentemente.")

       with gr.Row():
           with gr.Column(scale=1):  # Coluna esquerda: Configura√ß√£o (1/3 da tela)
               gr.Markdown("#### Configura√ß√£o dos Agentes")

               def load_config_fn():
                   try:
                       with open("agents_config.json", 'r', encoding='utf-8') as f:
                           return json.load(f)
                   except Exception as e:
                       return {"error": str(e)}

               def save_config_fn(config_data):
                   try:
                       with open("agents_config.json", 'w', encoding='utf-8') as f:
                           json.dump(config_data, f, indent=4, ensure_ascii=False)
                       return "‚úÖ Configura√ß√µes salvas com sucesso! Reinicie o backend se necess√°rio para aplicar."
                   except Exception as e:
                       return f"‚ùå Erro ao salvar: {str(e)}"

               config_output = gr.JSON(label="Configura√ß√£o Atual (Carregue para editar)", value=load_config_fn)

               load_config_btn = gr.Button("Carregar Configura√ß√£o Atual")
               load_config_btn.click(fn=load_config_fn, outputs=config_output)

               # Editor de Prioridades de Projeto
               project_select = gr.Dropdown(label="Escolha um Perfil de Projeto para Editar", choices=lambda: list(load_config_fn().get('project_priorities', {}).keys()))
               priorities_text = gr.TextArea(label="Ordem de Prioridade (uma fonte por linha)", lines=5)

               def update_priorities(project):
                   config = load_config_fn()
                   return "\n".join(config['project_priorities'].get(project, []))

               project_select.change(fn=update_priorities, inputs=project_select, outputs=priorities_text)

               # Editor de Instru√ß√µes do Agente Raciocinador
               reasoner_prompt_text = gr.TextArea(label="Prompt Base para ReasonerAgent", lines=10)
               classifier_prompt_text = gr.TextArea(label="Prompt Base para ClassifierAgent", lines=5)

               def update_prompts():
                   config = load_config_fn()
                   return config['reasoner_agent'].get('base_prompt', ""), config['classifier_agent'].get('base_prompt', "")

               update_prompts_btn = gr.Button("Atualizar Prompts")
               update_prompts_btn.click(fn=update_prompts, outputs=[reasoner_prompt_text, classifier_prompt_text])

               save_btn = gr.Button("Salvar Todas as Configura√ß√µes", variant="primary")
               save_status = gr.Textbox(label="Status da Salva√ß√£o")

               def save_all(project, priorities, reasoner_prompt, classifier_prompt):
                   config = load_config_fn()
                   config['project_priorities'][project] = [line.strip() for line in priorities.split('\n') if line.strip()]
                   config['reasoner_agent']['base_prompt'] = reasoner_prompt
                   config['classifier_agent']['base_prompt'] = classifier_prompt
                   return save_config_fn(config)

               save_btn.click(fn=save_all, inputs=[project_select, priorities_text, reasoner_prompt_text, classifier_prompt_text], outputs=save_status)

           with gr.Column(scale=2):  # Coluna direita: Teste e An√°lise (2/3 da tela)
               gr.Markdown("#### üß™ Teste e An√°lise de Racioc√≠nio")

               query_input = gr.Textbox(label="Digite a Query para Testar", value="assentamento de porcelanato 60x60cm", lines=2)
               project_profile_input = gr.Dropdown(label="Perfil de Projeto (para Prioridades)", choices=lambda: list(load_config_fn().get('project_priorities', {}).keys()), value="default")
               user_guidance_input = gr.TextArea(label="Orienta√ß√£o Manual para esta Busca (Opcional)", lines=5, placeholder="Ex: 'Foque na caracter√≠stica 'porcelanato'. Ignore o tamanho por agora e priorize fontes federais.'")

               execute_btn = gr.Button("Executar e Analisar Trace", variant="primary")
               results_output = gr.Dataframe(label="‚úÖ Resultado Final")
               trace_output = gr.JSON(label="üß† Trace Detalhado do Racioc√≠nio")
               status_output = gr.Textbox(label="Status da Execu√ß√£o")

               def execute_query(query, project_profile, user_guidance):
                   payload = {"texto_busca": query, "top_k": 3, "project_profile": project_profile, "user_guidance": user_guidance}
                   try:
                       response = requests.post("http://127.0.0.1:8000/buscar", json=payload, timeout=30)
                       if response.status_code == 200:
                           data = response.json()
                           return data.get('results', []), data.get('trace', {}), "‚úÖ Sucesso: Trace e resultados carregados."
                       else:
                           return [], {}, f"‚ùå Erro na API: {response.status_code} - {response.text}"
                   except Exception as e:
                       return [], {}, f"‚ùå Erro de conex√£o: {str(e)}"

               execute_btn.click(fn=execute_query, inputs=[query_input, project_profile_input, user_guidance_input], outputs=[results_output, trace_output, status_output])
   ```

Como Executar e Usar

1. Aplique as Modifica√ß√µes: Implemente todas as mudan√ßas no backend (routes.py, finder.py, reasoner.py, classifier_agent.py) e integre o c√≥digo acima no frontend Gradio em app_principal.py. Teste cada tarefa individualmente: rode pytest (se configurado) ou testes manuais para endpoints e configs.

2. Inicie o Backend: No terminal, execute uvicorn backend.api.main:app --reload --port 8000 (ajuste o path se necess√°rio para compatibilidade com a estrutura existente).

3. Inicie a Interface Gradio: No mesmo terminal ou outro, execute python app_principal.py (ou o comando equivalente para rodar o Gradio). Acesse http://127.0.0.1:7860 (porta default do Gradio) e navegue para a aba "Painel de Controle dos Agentes".

Com esta implementa√ß√£o assertiva e detalhada, voc√™ ter√° controle total e granular sobre os agentes. A interface Gradio garante responsividade cross-browser, com atualiza√ß√µes em tempo real via bot√µes e eventos. Refine iterativamente: ap√≥s salvar configs, teste queries para validar boosts e traces, garantindo que o sistema atinja precis√£o m√°xima em cen√°rios reais de constru√ß√£o civil. Se erros ocorrerem durante a implementa√ß√£o, adicione logging adicional e reporte-os explicitamente.